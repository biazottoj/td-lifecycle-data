td_item,classification,project,issue_number,issue_type,text,if_fixed,fixed_commit_hash,introduced_commit_hash
HBASE-21160|0,Design-Des,hbase,21160,comment_1,"Since the catch block currently re-throws IOException, that means the catch block is no longer needed. Please run with the change locally before attaching patch. Thanks",yes,1cf920db4395926c634ed0946a57dfa52227472f,-
HBASE-21160|0,Design-Des,hbase,21160,comment_2,Hi I found so many re-throws blocks in the file of . Should we resolve it all?,yes,1cf920db4395926c634ed0946a57dfa52227472f,-
HBASE-20975|0,Code-LQualCd,hbase,20975,comment_0,"+1 on removing it for now. We have optimized too much before getting things correct... Lets keep the logic simple first. Also, there are some bad style issues. At least lets remove the space between stackTail and --, it looks like -- And do not do assignment in the condition block of if. Lets change to",yes,a07e755625382d3904c935c21a4f240ede6d2f43,-
HBASE-20975|1,Test-LCvg,hbase,20975,comment_4,Please include a small change in hbase-server module so we can run more tests?,no,-,-
HBASE-20975|2,Design-Des,hbase,20975,comment_8,"The failed UTs are related, upload a patch to fix it. My fix reveals a bug which exists all the time... the acquire and release lock logic in procedure is a bit of mess here... For different procedures, we have holdLock() set to true of false, for procedures which holdLock() == true, we need to override hasLock() method to test whether we have the lock... when executing procedure, we acquire the lock and release it immediately. And when the procedure is success, we release the lock again in It works, since for procedure with holdLock = true, we call releaseLock() with force = false the first time, the lock wont release here, but in where we call releaseLock() with force = true, the lock will be released there. For procedure with holdLock = false, it also works since when the first time we call releaseLock() with force = false, the lock will release, and the second time we call relseaseLock in we only release it lock if procedure with holdLock=true. So releasing lock wont called twice But when rolling back, we acquire the lock but only release the lock for procedure with holdLock = true... *Rolling back for procedures with holdLock=false(e.g. most of the Table Procedures) will never release the lock...*",yes,a07e755625382d3904c935c21a4f240ede6d2f43,-
HBASE-20975|3,Code-MTCor,hbase,20975,description,"Find this one when investigating HBASE-20921, too. Here is some code from executeRollback in You can see my comments in the code above, reuseLock can cause the procedure executing(rollback) without a lock. Though I havent found any bugs introduced by this issue, it is indeed a potential bug need to fix. I think we can just remove the reuseLock logic. Acquire and release lock every time. Find another case that during rolling back, the procedures lock may not be released properly: see comment:",yes,a07e755625382d3904c935c21a4f240ede6d2f43,-
THRIFT-4830|0,Code-SlAlg,thrift,4830,description,ITNOA I think it useful and have some performance benefits to generate to_string function for enum beside of operator<< overloading.,yes,6a61dfabbf6ae2fa9fbbc3996590ebdbe38e569f,-
THRIFT-1745|0,Test-LacTst,thrift,1745,comment_0,"Frederic,Thank you for your work on this. Would you please attach the patch for this to the ticket. We can not accept gist or pull requests from github due to ASF licensing requirements. Once the test cases are added ill gladly review and commit this patch.",yes,"85fb6de7f4c1ea6260f98bc24401593e8c974bc7,05ab89a1286049567e8d6ada1833a7d75179a365",-
CAMEL-8091|0,Design-Des,camel,8091,description,"The does not consider the context property that is supposed to limit the size of the logged payload. It is possible to set a maxChars on the but that has a different semantics (limits the length of the formatted exchange,not of the message payload) and is complicated to set in some cases (e.g. in the case of the default error handler) The attached extension also honors the context property when formatting the exchange.",yes,43d02628287c0623672714a016e324d6da36d71c,-
IMPALA-8005|0,Design-Des,impala,8005,description,"Currently,we use the same hash seed for partitioning exchanges at the sender. For a table with skew in distribution in the shuffling keys,multiple queries using the same shuffling keys for exchanges will end up hashing to the same destination fragments running on particular host and potentially overloading that host. We should consider using the query id or other query specific information to seed the hashing function to randomize the destinations for different queries. Thanks to  for pointing this problem out.",yes,df6196e064bc7453bee8c7e644bb591391ee3ce2,-
CAMEL-11524|0,Code-LQualCd,camel,11524,comment_0,"No there is not,your workaround is to not use $ in the file name,which also is a bad habit to do so. The source code needs to be patched where you need to quote the file name in the GenericFileEndpoint method via You are welcome to work on a github PR to fix this",yes,1fa638ec156135ef9d5c6bb8684b81459c6c7c82,-
CAMEL-11524|0,Code-LQualCd,camel,11524,comment_1,"Hi Claus Thanks for the response. The source of the \$\ is Ola Hallengren\s SQL maintenance script and that in turn is escaping a \\\\ in a database engine name. It seems like a better idea to fix the Camel code and make it more robust. I will look into providing a patch for this. Regards,Saycat",yes,1fa638ec156135ef9d5c6bb8684b81459c6c7c82,-
CAMEL-1173|0,Code-LQualCd,camel,1173,comment_1,"Put in an improved scatter-gather example in revision 740056. The problem with the first example was that it was not dynamic enough. Also added wiki docs here",yes,f6cbe6529a1084383b72c06ab215a28dee3ebed7,-